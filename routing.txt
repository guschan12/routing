Роутинг на базе модуля Apache mod_rewrite

Долгое вря ЧПУ делались с помощью небезызвестного модуля веб-сервера Apache mod_rewrite,
который предназначен для манипуляции URL адресами. Директивы для mod_rewrite обычно писались разработчиками
в .htaccess файле конфигурации Apache и выглядели примерно так:


RewriteEngine on
RewriteBase /

# Досье пользователя.
RewriteRule ^users/([0-9]+)\.html$	userinfo.php?user_id=$1
# Список всех пользователей
RewriteRule ^users/?$			    users.php?%{QUERY_STRING}

# Новости общим списком
RewriteRule ^news/?$			    news.php
# Новости по разделам
RewriteRule ^news/([a-z_]+)/?$		news.php?cat=$1
# Страница одной новости
RewriteRule ^news/([0-9]+).html$	news.php?id=$1


Чем плох подобный механизм преобразований URL адресов, освоенный на mode_rewrite? Ничем не плох, но для разработки гибких веб-приложений он не подходит. В первую очередь потому, что преобразованием занимается сам mod_rewrite и система фактически завязана на файле конфигурации .htaccess. Мы не имеем возможности влиять на процесс преобразования, добавлять в автоматическом режиме новые виртуальные URL адреса, привязывать сложную логику к определённым виртуальным URL-адресам и делать многое другое. В конце-концов, файл конфигурации .htaccess всё-таки больше файл глобальных настроек уровня сервера и его модулей, но никак не web-приложения.

Роутинг на PHP
Конечно же, на одном PHP ЧПУ не сделать. Моудуль mode_rewrite как и раньше нужно использовать, но только лишь для того, что бы перенаправить все запросы к виртуальным ЧПУ-адресам в единую точку входа в приложении - в index.php. Для этого в .htaccess файле конфигурации можно прописать следующий код:

<IfModule mod_rewrite.c>
RewriteEngine On
Options +FollowSymlinks
RewriteBase /

RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule ^(.*)$ index.php [L,QSA]
</IfModule>


Данная запись означает буквально следующее: если запрошенный URL-адрес не является файлом и не является директорией, то подменить виртуальный адрес файлом index.php. При этом, суперглобальная переменная PHP $_SERVER['REQUEST_URI'] будет содержать именно запрошенный виртуальный адрес! Что это нам даёт? Фактически - безграничные возможности для манипулирования виртуальными адресами. Механизм разбора таких виртуальных URL-адресов на урвне PHP называется роутингом.